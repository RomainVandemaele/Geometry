<html>
<head>
  <script src="processing.js"></script>
</head>
<body><h1>Processing.js</a></h1>
<h2>Advanced processing.js via JavaScript</h2>
<p>Processing.js Cube</p>
<em>Note: runs via a web server or requres local files access in the web browser settings.</em>
Converted to the JavaScript language from the Processing code<br>
Original souce code:<a href="http://processing.org/learning/3d/texturecube.html">TexturedCube</a> 
by Dave Bollinger.

<canvas id="canvas1" width="200" height="200"></canvas>

<script id="script1" type="text/javascript">

//New code
var currentFace = null;


function Point(x, y, z) {
  this.x = x;
  this.y = y;
  this.z = z;
  this.getX = function () {return this.x;}
  this.getY = function () {return this.y;}
  this.getY = function () {return this.y;}
}

function Face(points) {
  this.points = [];
  this.vertices = [];
  this.edges = [];
  this.upFace = null;
  this.downFace = null;
  this.leftFace = null;
  this.rightFace = null;

  this.getUp = function () {return this.upFace;}
  this.getDown = function () {return this.downFace;}
  this.getLeft = function () {return this.leftFace;}
  this.getRight = function () {return this.rightFace;}

  this.addPoint = function (point) {this.points.push(point);}
  this.addVertex = function (vertex) {this.vertices.push(vertex);}
  this.addPoints = function (edge) {this.edges.push(edge);}

}


function init() {
	var p1 = new Point(1,1,1);
	var p2 = new Point(1,1,1);
	var p3 = new Point(1,1,1);
	var p4 = new Point(1,1,1);
	var p5 = new Point(1,1,1);
	var p6 = new Point(1,1,1);
	var p7 = new Point(1,1,1);
	var p8 = new Point(1,1,1);

	var f1 = new Face();
	var f2 = new Face();
	var f3 = new Face();
	var f4 = new Face();
	var f5 = new Face();
	var f6 = new Face();


}

// Attaching js code to the canvas by using a sketch object

var sketch = new Processing.Sketch();
// define 3D context
sketch.use3DContext = true;
// preload the images
sketch.imageCache.add("pjs.png");
// attach function (also, can be specified as the single parameter 
// in the Processing.Sketch object constructor)
sketch.attachFunction = function(processing) {
  var tex;
  var rotx = 0;
  var roty = 0;

  processing.setup = function() {
    processing.size(500, 500, processing.P3D);
    tex = processing.loadImage("pjs.png");
    processing.textureMode(processing.NORMALIZED);
    processing.fill(255);
    processing.stroke(processing.color(44,48,32));
    processing.frameRate(200);
  };

  processing.draw = function() {
    processing.background(0);
    processing.noStroke();
    processing.translate(processing.width/2.0, 
                         processing.height/2.0, -100);
    processing.rotateX(rotx);
    processing.rotateY(roty);
    processing.scale(100);
    texturedCube(tex);
    //processing.frame.setTitle(int(frameRate) + " fps");
  }

  function texturedCube(tex) {
    processing.beginShape(processing.QUADS);
    processing.texture(tex);

    // Given one texture and six faces, we can easily set up the uv coordinates
    // such that four of the faces tile "perfectly" along either u or v, but the other
    // two faces cannot be so aligned.  This code tiles "along" u, "around" the X/Z faces
    // and fudges the Y faces - the Y faces are arbitrarily aligned such that a
    // rotation along the X axis will put the "top" of either texture at the "top"
    // of the screen, but is not otherwised aligned with the X/Z faces. (This
    // just affects what type of symmetry is required if you need seamless
    // tiling all the way around the cube)
    
    // +Z "front" face
    processing.vertex(-1, -1,  1, 0, 0);
    processing.vertex( 1, -1,  1, 1, 0);
    processing.vertex( 1,  1,  1, 1, 1);
    processing.vertex(-1,  1,  1, 0, 1);

    // -Z "back" face
    processing.vertex( 1, -1, -1, 0, 0);
    processing.vertex(-1, -1, -1, 1, 0);
    processing.vertex(-1,  1, -1, 1, 1);
    processing.vertex( 1,  1, -1, 0, 1);

    // +Y "bottom" face
    processing.vertex(-1,  1,  1, 0, 0);
    processing.vertex( 1,  1,  1, 1, 0);
    processing.vertex( 1,  1, -1, 1, 1);
    processing.vertex(-1,  1, -1, 0, 1);

    // -Y "top" face
    processing.vertex(-1, -1, -1, 0, 0);
    processing.vertex( 1, -1, -1, 1, 0);
    processing.vertex( 1, -1,  1, 1, 1);
    processing.vertex(-1, -1,  1, 0, 1);

    // +X "right" face
    processing.vertex( 1, -1,  1, 0, 0);
    processing.vertex( 1, -1, -1, 1, 0);
    processing.vertex( 1,  1, -1, 1, 1);
    processing.vertex( 1,  1,  1, 0, 1);

    // -X "left" face
    processing.vertex(-1, -1, -1, 0, 0);
    processing.vertex(-1, -1,  1, 1, 0);
    processing.vertex(-1,  1,  1, 1, 1);
    processing.vertex(-1,  1, -1, 0, 1);

    processing.endShape();
  }

  // mouse event
  processing.mouseDragged = function() {
    var rate = 0.01;
    rotx += (processing.mouseY-processing.pmouseY) * rate;
    roty += (processing.mouseX-processing.pmouseX) * rate;
  };

  processing.keyPressed = function() {

  	if (processing.keyCode == processing.UP) {
  		//window.alert("UP");
  		rotx += Math.PI/2;
    }else if (processing.keyCode == processing.DOWN) {
    	rotx -= Math.PI/2;
    }else if (processing.keyCode == processing.LEFT) {
    	roty -= Math.PI/2;
    }else if (processing.keyCode == processing.RIGHT) {
    	roty += Math.PI/2;
    }else if (processing.key == 114) { //key r(eset)
    	roty  = 0;
    	rotx  = 0;
    }

  };

  processing.mouseClicked = function () {
    /*X : 403 Y : 92
	X : 234 Y : 93
	X : 234 Y : 264
	X : 402 Y : 262*/
    processing.hint(DISABLE_DEPTH_TEST);
  	processing.camera();
  	processing.noLights();

    processing.fill(255,0,0);
    processing.line(0,0,1,1);
    processing.fill(255);
    processing.println("X : " + processing.mouseX+" Y : "+ processing.mouseY);
    processing.ellipse(56, 46, 55, 55);

    processing.hint(ENABLE_DEPTH_TEST);
    //new Point(processing.mouseX,processing.mouseY);
  };

};



var canvas = document.getElementById("canvas1");
// attaching the sketch to the canvas
var p = new Processing(canvas, sketch);

</script>
