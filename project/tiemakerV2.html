<html>
<head>
  <script src="processing.js"></script>
   <script src="math.js"></script>
   <script src="Point.js"></script>
   <script src="Polygon.js"></script>
   <script src="geometry.js"></script>
   <script src="FlatTorrus.js"></script>
   <script src="FlatTriangle.js"></script>
   <script src="KleinBottle.js"></script>
</head>
<body><h1>Processing.js</a></h1>
<h2>Advanced processing.js via JavaScript</h2>


<canvas id="canvas1" width="200" height="200"></canvas>
<canvas id="canvas2" width="200" height="200"></canvas>

<script id="script1" type="text/javascript">
/*TO DO/IDEE :
-ctrl-2

Part 2 :
-delete
-avoid crossing in move and rotating
-emboitement


*/

var tilemaker;
var polygons = [];
var selectedPolygon = null;
var selectedPoint =  null;

var pointSize = 8;
var CANVAS_WIDTH = 1500;
var CANVAS_HEIGHT = 750;

var FOLDING = 1;
var TILING = 2;
var MODE = FOLDING;

var MOVING = 0;
var ROTATING = 1;
var TILING_MODE = MOVING;



function init(proc) {
    tilemaker = new KleinBottle(new Point(CANVAS_WIDTH/2 - 300,CANVAS_HEIGHT/2),proc);
    //tilemaker = new FlatTorrus(new Point(CANVAS_WIDTH/2,CANVAS_HEIGHT/2),proc);
    tilemaker.draw();
    tilemaker.crossed();
}



// Attaching js code to the canvas by using a sketch object

var sketch = new Processing.Sketch();

sketch.attachFunction = function(processing) {
 
  processing.setup = function() {
    processing.background(155);
    processing.fill(100);
    processing.size(CANVAS_WIDTH, CANVAS_HEIGHT);
    processing.fill(255);
    //processing.frameRate(200);
    init(processing);
  };

  processing
  

  processing.draw = function() {
    if(MODE == TILING  ) {
      
      processing.background(155);
      for(j=polygons.length-1;j>=0;j--) {
        //processing.println("DRAW POLYGON "+j);
        polygons[j].draw();
        //processing.println("DRAWED POLYGON "+j);
      }
      if(selectedPoint!=null) {
        processing.ellipse(selectedPoint.getX(), selectedPoint.getY(),pointSize,pointSize);
      }
    }
    
  }

  
  // mouse event
  processing.mouseDragged = function() {
    if(MODE== FOLDING &&  tilemaker.hasStarted() && !tilemaker.hasEnded()) {
      //tilemaker.addPoint(processing.mouseX,processing.mouseY);
    }else if(MODE==TILING && selectedPolygon!=null ) { //&& polygon.isInPolygon(
      if(TILING_MODE == MOVING) {
        selectedPolygon.move(processing.mouseX - processing.pmouseX, processing.mouseY - processing.pmouseY); 
        //processing.println("test overlapping 1");
        var test = polygonsCrossing(selectedPolygon,polygons);
        //processing.println("test overlapping 2 ");
        if(test==true) {
          selectedPolygon.move( - (processing.mouseX - processing.pmouseX),- (processing.mouseY - processing.pmouseY)); 
        }
      }else if(TILING_MODE == ROTATING) {
        //processing.println("ROTATE");
        selectedPolygon.rotate(2);
        var test = polygonsCrossing(polygons,processing);
        if(test==true) {
          selectedPolygon.rotate(-2);
        }
      }
      
    }
  };

  processing.keyPressed = function() {
    processing.println(processing.key);
  	if (processing.keyCode == processing.ENTER) {
  		if(tilemaker.hasEnded()) {
        processing.background(155); //clean 
        //processing.println("ENTER");
        var polys = tilemaker.drawUnFolded();
        //processing.println("UNFOLDED "+polys.length );
        for( j = 0; j<polys.length;j++) {
          //processing.println("ADD POLY "+j);
          polygons.push(polys[j]);
        }
        MODE = TILING;
      }
    }else if (processing.keyCode == processing.DOWN) {
    	//rotx -= Math.PI/2;
    }else if (processing.key == 116) { //key = t(est)
      if(MODE == TILING) {
        processing.println("TEST");
        var res = tilePlane(0,polygons,processing);
        processing.println(res);
      }
    }else if (processing.key == 115) { //key = "s"witch
      if(MODE == TILING) {
        TILING_MODE = (TILING_MODE + 1 ) %2 
      }
    }else if (processing.key == 114) { //key == r(reset)
      if(MODE== FOLDING &&  tilemaker.hasStarted()) { //folding already begun
        tilemaker.resetMove();
      }else if(MODE == TILING) { //TODO : change if better usage found
        MODE = FOLDING;
        tilemaker.resetMove();
        polygons = [];
      }
    }

  };

  processing.mousePressed = function () {
    if (processing.mouseButton == processing.LEFT) {
      if(MODE == FOLDING ) { //folding already begined
        if(!tilemaker.hasStarted()) {
          tilemaker.begin(processing.mouseX,processing.mouseY); 
        }else if(!tilemaker.hasEnded()){
          tilemaker.addPoint(processing.mouseX,processing.mouseY);
        }
      }else if(MODE == TILING) {
        var i = 0;
        var found = false;
        while(i < polygons.length && !found) {
          //processing.println("SEARCH POLYGON "+i);
          if(polygons[i].isInPolygon(processing.mouseX,processing.mouseY)) {
            //processing.println("FOUND POLYGON "+i);
            if(selectedPolygon == polygons[i] || selectedPolygon == null) {
              polygons[i].select();
              if(polygons[i].isSelected()) {
                selectedPolygon = polygons[i];
              }else {
                selectedPolygon = null;
              }
            } 
            found = true;
          }
          i++
        }
      }
    }else if(processing.mouseButton == processing.RIGHT) {
        if(MODE == TILING && selectedPolygon!=null) {
          //processing.println("OK");
          polygons.push(selectedPolygon.copy());
          //processing.println("POLYGON CREATED : "+polygons[polygons.length - 1].getLenght());
          //polygons[polygons.length-1].draw();
        }
    }
  
  };

};



var canvas = document.getElementById("canvas1");
// attaching the sketch to the canvas
var p = new Processing(canvas, sketch);



</script>
</body>
</html>