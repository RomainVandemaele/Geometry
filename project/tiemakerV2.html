<html>
<head>
  <script src="processing.js"></script>
   <script src="math.js"></script>
   <script src="Point.js"></script>
   <script src="Polygon.js"></script>
   <script src="geometry.js"></script>
   <script src="FlatTorrus.js"></script>
   <script src="FlatRectangle.js"></script>
   <script src="FlatTriangle.js"></script>
   <script src="IRTD.js"></script>
   <script src="HETD.js"></script>
   <script src="KleinBottle.js"></script>
   <script src="Face.js"></script>
   <script src="Tetrahedra.js"></script>
</head>
<body><h1>Processing.js</a></h1>
<h2>Advanced processing.js via JavaScript</h2>


<canvas id="canvas1" width="200" height="200"></canvas>
<canvas id="canvas2" width="200" height="200"></canvas>

<script id="script1" type="text/javascript">
/*TO DO/IDEE :
-ctrl-2

Part 2 :
-delete
-emboitement


*/

var tilemaker;
var polygons = [];
var selectedPolygon = null;
var selectedPoint =  null;

var pointSize = 8;
var CANVAS_WIDTH = 1500;
var CANVAS_HEIGHT = 750;

var INIT = 0;
var FOLDING = 1;
var TILING = 2;
var MODE = INIT;

var MOVING = 0;
var ROTATING = 1;
var TILING_MODE = MOVING;



function init(proc) {
    //tilemaker = new KleinBottle(new Point(CANVAS_WIDTH/2 - 300,CANVAS_HEIGHT/2),proc);
    //tilemaker = new FlatRectangle(new Point(CANVAS_WIDTH/2-300,CANVAS_HEIGHT/2-100),proc);

    var mode = prompt("Choose mode :\n1. Cutting\n2.Tiling ","1")
    if(mode == 1) {
      var msg = "Choose you tilemaker :\n1. Flat Rectangle\n";
      msg += "2. Equilateral triangle\n";
      msg += "3. isoceles right triangle\n";
      msg += "4. half equilateral triangle\n";
      msg += "5. Flat Torrus\n";
      msg += "6. Flat klein bottle\n";
      msg += "7. Tetrahedra\n";
      msg += "8. Real projective palne\n";
      var choice = prompt(msg, "1");

      switch(choice) {
        case "1":
        tilemaker = new FlatRectangle(new Point(CANVAS_WIDTH/2-300,CANVAS_HEIGHT/2-100),proc);
        break;
        case "2":
        tilemaker = new ETD(new Point(CANVAS_WIDTH/2-300,CANVAS_HEIGHT/2-100),proc);
        break;
        case "3":
        tilemaker = new IRTD(new Point(CANVAS_WIDTH/2-300,CANVAS_HEIGHT/2-100),proc);
        break;
        case "4":
        tilemaker = new HETD(new Point(CANVAS_WIDTH/2-300,CANVAS_HEIGHT/2-100),proc);
        break;
        case "5":
        tilemaker = new FlatTorrus(new Point(CANVAS_WIDTH/2-300,CANVAS_HEIGHT/2-100),proc);
        break;
        case "6":
        tilemaker = new KleinBottle(new Point(CANVAS_WIDTH/2-300,CANVAS_HEIGHT/2-100),proc);
        break;
        case "7":
        tilemaker = new Tetrahedra(new Point(CANVAS_WIDTH/2-300,CANVAS_HEIGHT/2-100),proc);
        break;
        case "8":
        tilemaker = new FlatTorrus(new Point(CANVAS_WIDTH/2-300,CANVAS_HEIGHT/2-100),proc);
        break;
      }

      //initTilemaker(choice);
      tilemaker.draw();
      MODE = FOLDING;
    }else if(mode==2) {
      MODE = TILING;
    }

}

function initTilemaker(choice) {
  switch(choice) {
    case "1":
        window.alert("cas 1");
        tilemaker = new FlatRectangle(new Point(CANVAS_WIDTH/2-300,CANVAS_HEIGHT/2-100),proc);
        window.alert("cas 1 end");
        break;
    case "2":
        window.alert("cas 2");
        tilemaker = new ETD(new Point(CANVAS_WIDTH/2-300,CANVAS_HEIGHT/2-100),proc);
        window.alert("cas 2 end");
        break;
    }
}



// Attaching js code to the canvas by using a sketch object

var sketch = new Processing.Sketch();

sketch.attachFunction = function(processing) {

  processing.setup = function() {
    processing.background(155);
    processing.fill(100);
    processing.size(CANVAS_WIDTH, CANVAS_HEIGHT);
    processing.fill(255);
    //processing.frameRate(200);
    init(processing);
  };




  processing.draw = function() {
    if(MODE == TILING  ) {

      processing.background(155);
      for(j=polygons.length-1;j>=0;j--) {
        //processing.println("DRAW POLYGON "+j);
        polygons[j].draw();
        //polygons[j].displayCenter();
        //processing.println("DRAWED POLYGON "+j);
      }
      if(selectedPoint!=null) {
        processing.ellipse(selectedPoint.getX(), selectedPoint.getY(),pointSize,pointSize);
      }
    }

  }


  // mouse event
  processing.mouseDragged = function() {
    if(MODE== FOLDING &&  tilemaker.hasStarted() && !tilemaker.hasEnded()) {
      //tilemaker.addPoint(processing.mouseX,processing.mouseY);
    }else if(MODE==TILING && selectedPolygon!=null ) { //&& polygon.isInPolygon(
      if(TILING_MODE == MOVING) {
        selectedPolygon.move(processing.mouseX - processing.pmouseX, processing.mouseY - processing.pmouseY,true);
        //processing.println("test overlapping 1");
        var test = polygonsCrossing(selectedPolygon,polygons);
        //processing.println("test overlapping 2 ");
        if(test==true) {
          selectedPolygon.move( - (processing.mouseX - processing.pmouseX),- (processing.mouseY - processing.pmouseY),true);
        }
      }else if(TILING_MODE == ROTATING) {
        //processing.println("ROTATE");
        selectedPolygon.rotate(1,true);
        var test = polygonsCrossing(selectedPolygon,polygons);
        if(test==true) {
          selectedPolygon.rotate(-1,true);
        }
      }

    }
  };

  processing.keyPressed = function() {
    processing.println(processing.key);

    if(MODE == INIT) {

      var code = processing.key - 48;
      if(code >0 && code <5 ) {
        if(code==1) {
          //processing.println("Rectangle");
          tilemaker  = new FlatRectangle(new Point(CANVAS_WIDTH/2 - 300,CANVAS_HEIGHT/2),processing);
           //processing.println("Completed");
        }else if(code==2) {
          tilemaker  = new ETD(new Point(CANVAS_WIDTH/2 - 300,CANVAS_HEIGHT/2),processing);
        }else if(code==3) {
          tilemaker  = new FlatTorrus(new Point(CANVAS_WIDTH/2 - 300,CANVAS_HEIGHT/2),processing);
        }else if(code==4) {
          tilemaker  = new KleinBottle(new Point(CANVAS_WIDTH/2 - 300,CANVAS_HEIGHT/2),processing);
        }else if(code==5) {
          tilemaker = new Tetrahedra(new Point(CANVAS_WIDTH/2,CANVAS_HEIGHT/2),proc);
        }
        MODE = FOLDING;
        tilemaker.draw();
      }
    }


  	if (processing.keyCode == processing.ENTER) {
  		if(MODE == FOLDING &&  tilemaker.hasEnded()) {
        processing.background(155); //clean
        var polys = tilemaker.drawUnFolded();
        //polygons.push(polys);
        for( j = 0; j<polys.length;j++) {
          polygons.push(polys[j]);
        }
        MODE = TILING;
      }
    }else if (processing.key == 116) { //key = t(est)
      if(MODE == TILING) {
        processing.println("TEST");
        var res = false;
        var i   = 0;
        while(!res && i <polygons.length) {
          res = tilePlane(i,polygons,processing);
          i++;
        }
        //var res = tilePlane(0,polygons,processing);
        if(res) {
          window.alert("The tiling is correct");
        }else {
          window.alert("Incorrect tiling");
        }
        processing.println(res);
      }
    }else if (processing.key == 115) { //key = "s"witch
      if(MODE == TILING) {
        TILING_MODE = (TILING_MODE + 1 ) %2
      }
    }else if (processing.key == 114) { //key == r(reset)
      if(MODE== FOLDING &&  tilemaker.hasStarted()) { //folding already begun
        tilemaker.resetMove();
        processing.background(155);
        init(processing);
        //MODE =INIT;
      }else if(MODE == TILING) { //TODO : change if better usage found
        MODE = FOLDING;
        tilemaker.resetMove();
        polygons = [];
      }
    }

  };

  processing.mousePressed = function () {
    //processing.println("INPUT");
    if (processing.mouseButton == processing.LEFT) {
      //processing.println("CLICK "+MODE);
      if(MODE == FOLDING ) { //folding already begined
        //processing.println("PRE_BEGIN");
        if(!tilemaker.hasStarted()) {
          //processing.println("BEGIN");
          tilemaker.begin(processing.mouseX,processing.mouseY);
        }else if(!tilemaker.hasEnded()){
          //processing.println("ADD POINT");
          tilemaker.addPoint(processing.mouseX,processing.mouseY);
        }

      }else if(MODE == TILING) {
        //processing.println("TILING");
        var i = 0;
        var found = false;
        while(i < polygons.length && !found) {
          //processing.println("SEARCH POLYGON "+i);
          if(polygons[i].isInPolygon(processing.mouseX,processing.mouseY)) {
            //processing.println("FOUND POLYGON "+i);
            if(selectedPolygon == polygons[i] || selectedPolygon == null) {
              polygons[i].select(true);
              if(polygons[i].isSelected()) {
                selectedPolygon = polygons[i];
              }else {
                selectedPolygon = null;
              }
            }
            found = true;
          }
          i++
        }
      }
      //processing.println("END");
    }else if(processing.mouseButton == processing.RIGHT) {
        if(MODE == TILING && selectedPolygon!=null) {
          //processing.println("OK");
          var polys = selectedPolygon.copy(true);
          for(var k=0;k<polys.length;k++) {
              polygons.push(polys[k]);
              for(var i=0;i<polygons.length-1;i++) {
                while(polys[k].isOverlapping(polygons[i])) {
                  polys[k].move(10,10);
                }
              }

          }
          //processing.println("POLYGON CREATED : "+polygons[polygons.length - 1].getLenght());
          //polygons[polygons.length-1].draw();
        }
    }

  };

};



var canvas = document.getElementById("canvas1");
// attaching the sketch to the canvas
var p = new Processing(canvas, sketch);



</script>
</body>
</html>
