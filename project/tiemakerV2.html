<html>
<head>
  <script src="processing.js"></script>
   <script src="math.js"></script>
   <script src="Point.js"></script>
   <script src="Polygon.js"></script>
   <script src="geometry.js"></script>
   <script src="FlatTorrus.js"></script>
   <script src="FlatRectangle.js"></script>
   <script src="FlatTriangle.js"></script>
   <script src="KleinBottle.js"></script>
   <script src="Face.js"></script>
   <script src="Tetrahedra.js"></script>
</head>
<body><h1>Processing.js</a></h1>
<h2>Advanced processing.js via JavaScript</h2>


<canvas id="canvas1" width="200" height="200"></canvas>
<canvas id="canvas2" width="200" height="200"></canvas>

<script id="script1" type="text/javascript">
/*TO DO/IDEE :
-ctrl-2

Part 2 :
-delete
-avoid crossing in rotation
-emboitement


*/

var tilemaker;
var polygons = [];
var selectedPolygon = null;
var selectedPoint =  null;

var pointSize = 8;
var CANVAS_WIDTH = 1500;
var CANVAS_HEIGHT = 750;

var INIT = 0;
var FOLDING = 1;
var TILING = 2;
var MODE = FOLDING;

var MOVING = 0;
var ROTATING = 1;
var TILING_MODE = MOVING;



function init(proc) {
    //tilemaker = new KleinBottle(new Point(CANVAS_WIDTH/2 - 300,CANVAS_HEIGHT/2),proc);
    tilemaker = new Tetrahedra(new Point(CANVAS_WIDTH/2-300,CANVAS_HEIGHT/2-100),proc);
    tilemaker.draw();
    /*proc.println("Choose you tilemaker :");
    proc.println("1. Flat Rectangle");
    proc.println("2. Equilateral triangle");
    proc.println("3. Flat Torrus");
    proc.println("4. Flat klein bottle");
    proc.println("5. Tetrahedra");*/
}



// Attaching js code to the canvas by using a sketch object

var sketch = new Processing.Sketch();

sketch.attachFunction = function(processing) {

  processing.setup = function() {
    processing.background(155);
    processing.fill(100);
    processing.size(CANVAS_WIDTH, CANVAS_HEIGHT);
    processing.fill(255);
    //processing.frameRate(200);
    init(processing);
  };




  processing.draw = function() {
    if(MODE == TILING  ) {

      processing.background(155);
      for(j=polygons.length-1;j>=0;j--) {
        //processing.println("DRAW POLYGON "+j);
        polygons[j].draw();
        polygons[j].displayCenter();
        //processing.println("DRAWED POLYGON "+j);
      }
      if(selectedPoint!=null) {
        processing.ellipse(selectedPoint.getX(), selectedPoint.getY(),pointSize,pointSize);
      }
    }

  }


  // mouse event
  processing.mouseDragged = function() {
    if(MODE== FOLDING &&  tilemaker.hasStarted() && !tilemaker.hasEnded()) {
      //tilemaker.addPoint(processing.mouseX,processing.mouseY);
    }else if(MODE==TILING && selectedPolygon!=null ) { //&& polygon.isInPolygon(
      if(TILING_MODE == MOVING) {
        selectedPolygon.move(processing.mouseX - processing.pmouseX, processing.mouseY - processing.pmouseY);
        //processing.println("test overlapping 1");
        var test = polygonsCrossing(selectedPolygon,polygons);
        //processing.println("test overlapping 2 ");
        if(test==true) {
          selectedPolygon.move( - (processing.mouseX - processing.pmouseX),- (processing.mouseY - processing.pmouseY));
        }
      }else if(TILING_MODE == ROTATING) {
        //processing.println("ROTATE");
        selectedPolygon.rotate(1);
        var test = polygonsCrossing(polygons,processing);
        if(test==true) {
          selectedPolygon.rotate(-1);
        }
      }

    }
  };

  processing.keyPressed = function() {
    processing.println(processing.key);

    if(MODE == INIT) {

      var code = processing.key - 48;
      if(code >0 && code <5 ) {
        if(code==1) {
          //processing.println("Rectangle");
          tilemaker  = new FlatRectangle(new Point(CANVAS_WIDTH/2 - 300,CANVAS_HEIGHT/2),processing);
           //processing.println("Completed");
        }else if(code==2) {
          tilemaker  = new ETD(new Point(CANVAS_WIDTH/2 - 300,CANVAS_HEIGHT/2),processing);
        }else if(code==3) {
          tilemaker  = new FlatTorrus(new Point(CANVAS_WIDTH/2 - 300,CANVAS_HEIGHT/2),processing);
        }else if(code==4) {
          tilemaker  = new KleinBottle(new Point(CANVAS_WIDTH/2 - 300,CANVAS_HEIGHT/2),processing);
        }else if(code==5) {
          tilemaker = new Tetrahedra(new Point(CANVAS_WIDTH/2,CANVAS_HEIGHT/2),proc);
        }
        MODE = FOLDING;
        tilemaker.draw();
      }
    }


  	if (processing.keyCode == processing.ENTER) {
  		if(tilemaker.hasEnded()) {
        processing.background(155); //clean
        //processing.println("ENTER");
        var polys = tilemaker.drawUnFolded();
        //processing.println("UNFOLDED "+polys.length );
        for( j = 0; j<polys.length;j++) {
          //processing.println("ADD POLY "+j);
          polygons.push(polys[j]);
        }
        MODE = TILING;
      }
    }else if (processing.key == 116) { //key = t(est)
      if(MODE == TILING) {
        processing.println("TEST");
        var res = tilePlane(0,polygons,processing);
        processing.println(res);
      }
    }else if (processing.key == 115) { //key = "s"witch
      if(MODE == TILING) {
        TILING_MODE = (TILING_MODE + 1 ) %2
      }
    }else if (processing.key == 114) { //key == r(reset)
      if(MODE== FOLDING &&  tilemaker.hasStarted()) { //folding already begun
        tilemaker.resetMove();
        processing.background(155);
        init(processing);
        MODE =INIT;
      }else if(MODE == TILING) { //TODO : change if better usage found
        MODE = FOLDING;
        tilemaker.resetMove();
        polygons = [];
      }
    }

  };

  processing.mousePressed = function () {
    if (processing.mouseButton == processing.LEFT) {
      if(MODE == FOLDING ) { //folding already begined
        if(!tilemaker.hasStarted()) {
          tilemaker.begin(processing.mouseX,processing.mouseY);
        }else if(!tilemaker.hasEnded()){
          tilemaker.addPoint(processing.mouseX,processing.mouseY);
        }
      }else if(MODE == TILING) {
        var i = 0;
        var found = false;
        while(i < polygons.length && !found) {
          //processing.println("SEARCH POLYGON "+i);
          if(polygons[i].isInPolygon(processing.mouseX,processing.mouseY)) {
            //processing.println("FOUND POLYGON "+i);
            if(selectedPolygon == polygons[i] || selectedPolygon == null) {
              polygons[i].select();
              if(polygons[i].isSelected()) {
                selectedPolygon = polygons[i];
              }else {
                selectedPolygon = null;
              }
            }
            found = true;
          }
          i++
        }
      }
    }else if(processing.mouseButton == processing.RIGHT) {
        if(MODE == TILING && selectedPolygon!=null) {
          //processing.println("OK");
          polygons.push(selectedPolygon.copy());
          //processing.println("POLYGON CREATED : "+polygons[polygons.length - 1].getLenght());
          //polygons[polygons.length-1].draw();
        }
    }

  };

};



var canvas = document.getElementById("canvas1");
// attaching the sketch to the canvas
var p = new Processing(canvas, sketch);



</script>
</body>
</html>
